/* ----------------------------------------------
 * Ethernet Traffic Generator
 * Opsero Electronic Design Inc. 2016
 * ----------------------------------------------
 *
 * Description:
 * ------------
 * This IP generates Ethernet frames and checks received Ethernet frames for bit
 * errors. It is designed to be interfaced with the AXI Ethernet Subsystem block.
 * The frames contain random data generated by an LFSR for simple verification at the
 * receiver. The LFSR is reset for each frame, thus the transmitted frame is always
 * the same and can be easily verified by the receiver.
 *
 * The frame generator (TXD handler) provides the FCS (checksum) to the MAC. Normally
 * we wouldn't provide the FCS to the MAC because it can calculate it automatically,
 * but in our case, we need to provide it so that we can generate forced errors in
 * the frame which will cause the FCS to be incorrect for the frame. Thus the
 * receiver MAC will reject it, and we can count a rejected frame.
 *
 * The frame receiver (RXD handler) reads the incoming Ethernet frames and compares
 * them with the known transmitted frame. Any errors found are pushed into a stream
 * which is read by the error handler and added to the bit error counter. The bit
 * error counter is written to a software register which can be read by the processor.
 * Note that most bit errors will be detected by the receiving MAC and dropped, due
 * to the incorrect FCS. We check all frames that get through the MAC in order to
 * catch any bit errors that slip through undetected by the FCS calculation.
 *
 * Limitations:
 * ------------
 * This design does not currently contain an FCS calculator, so instead it contains
 * 2 fixed FCS values, which correspond to a pkt_len of 16 words and 374 words
 * respectively. The FCS values are based on MAC dst and src addresses of
 * FF FF FF FF 1E 00 and FF FF A4 A5 27 37 respectively. So although the design
 * allows for configuration of MAC addresses and packet length, it will only
 * function using the values mentioned above. An FCS calculator will be a future
 * addition to this example design.
 *
 */
#include <stdio.h>
#include <hls_stream.h>
#include <ap_int.h>

using namespace hls;

struct axiWord {
  ap_uint<32> data;
  ap_uint<4> keep;
  ap_uint<1> last;
};

struct param_struct {
	ap_uint<32> mac_addr_0;
	ap_uint<32> mac_addr_1;
	ap_uint<32> mac_addr_2;
	ap_uint<32> pkt_len;
	ap_uint<32> ethertype;
	ap_uint<32> fcs;
};

/* ----------------------------------------------
 * Combine MAC addresses
 * ----------------------------------------------
 * Combines DST and SRC MAC addresses into the 3 words that
 * are used in the Ethernet frame.
 *
 */
void combine_mac_addr(ap_uint<32> dst_mac_lo,
		ap_uint<32> dst_mac_hi,
		ap_uint<32> src_mac_lo,
		ap_uint<32> src_mac_hi,
		ap_uint<32> *mac_addr_0,ap_uint<32> *mac_addr_1,ap_uint<32> *mac_addr_2) {
#pragma HLS pipeline II=1 enable_flush
	ap_uint<16> uint16_hi_0;
	ap_uint<16> uint16_lo_0;
	ap_uint<16> uint16_hi_1;
	ap_uint<16> uint16_lo_1;
	// combine dest and src mac addresses into the 3 x 32 bit words
	uint16_hi_0 = dst_mac_hi.range(15,0);
	uint16_lo_0 = dst_mac_lo.range(31,16);
	*mac_addr_0 = uint16_hi_0.concat(uint16_lo_0);

	uint16_hi_1 = dst_mac_lo.range(15,0);
	uint16_lo_1 = src_mac_hi.range(15,0);
	*mac_addr_1 = uint16_hi_1.concat(uint16_lo_1);

	*mac_addr_2 = src_mac_lo;
}

/* ----------------------------------------------
 * Ethertype calculator
 * ----------------------------------------------
 * Generates the Ethertype word based on the packet length.
 *
 */
ap_uint<32> calc_ethertype(unsigned int pkt_len) {
#pragma HLS pipeline II=1 enable_flush
	ap_uint<8> uint8_hi = 0;
	ap_uint<8> uint8_lo = 0;
	ap_uint<16> pkt_len_bytes = 0;

	// Convert the packet length in words, to packet length in bytes
	pkt_len_bytes = (pkt_len * 4) + 2;
	// Then switch byte order to form the Ethertype
	uint8_hi = pkt_len_bytes.range(7,0);
	uint8_lo = pkt_len_bytes.range(15,8);
	return(uint8_hi.concat(uint8_lo));
}

/* ----------------------------------------------
 * LFSR Random number generator
 * ----------------------------------------------
 * Generates random data for the transmitted Ethernet frames.
 *
 */
ap_uint<32> lfsr_next(ap_uint<32> *lfsr) {
#pragma HLS pipeline II=1 enable_flush
	if((*lfsr)[31] == 1){
		*lfsr = (((*lfsr) ^ 0x00000062) << 1) | 1;
	}
	else{
		*lfsr = ((*lfsr) << 1);
	}

	return(*lfsr);
}

/* ----------------------------------------------
 * Force error handler
 * ----------------------------------------------
 * Monitors the force_error software register and triggers a bit error
 * when low-to-high transition is detected. Bit error is triggered by
 * writing to the force_error_trig stream.
 *
 */
void force_error_handler(ap_uint<1> *force_error,stream<ap_uint<1> >& force_error_trig) {
#pragma HLS pipeline II=1 enable_flush

	static ap_uint<1> sig_r = 0;

	if(sig_r != *force_error){
		if((*force_error == 1) && (sig_r == 0)){
			force_error_trig.write(1);
		}
		sig_r = *force_error;
	}
}


/* ----------------------------------------------
 * TXC Transmit handler
 * ----------------------------------------------
 * Transmits control frames to the AXI Ethernet Subsystem.
 *
 */
void txc_handler(stream<axiWord>& txc,
				stream<ap_uint<1> >& txc_trig){
#pragma HLS pipeline II=1 enable_flush
	static enum txcState {TXC_IDLE = 0, TXC_CTRLFRAME_0,TXC_CTRLFRAME_1} txcState;

	static axiWord currWord = {0, 0xF, 0};
	static ap_uint<32> i = 0;
	ap_uint<1> trig = 0;

	switch(txcState) {
	case TXC_IDLE:
		// Wait for the TXD handler to trigger a frame
		if(!txc_trig.empty()){
			txc_trig.read(trig);
			// Start sending the control frame
			currWord.last = 0;
			currWord.data = 0xA0000000;
			txc.write(currWord);
			i = 0;
			txcState = TXC_CTRLFRAME_0;
		}
		break;
	case TXC_CTRLFRAME_0:
		// Send the rest of the control frame
		currWord.data = 0;
		txc.write(currWord);
		if(i == 3)
			txcState = TXC_CTRLFRAME_1;
		i++;
		break;
	case TXC_CTRLFRAME_1:
		// Send the last word
		currWord.data = 0;
		currWord.last = 1;
		txc.write(currWord);
		txcState = TXC_IDLE;
		break;
	  }
}


/* ----------------------------------------------
 * TXD Transmit handler
 * ----------------------------------------------
 * Transmits Ethernet frames to the AXI Ethernet Subsystem.
 * The frames are composed as follows:
 *  - 3 words for destination and source MAC addresses
 *  - 1 word for Ethertype and padding
 *  - n words for the payload where n=pkt_len
 *  - 1 word for FCS (checksum)
 *
 * The AXIS interface is 32 bits (one word).
 * The AXIS keep outputs are always 1, ie. all bytes are used.
 * The payload is filled with random data generated from an
 * LFSR.
 *
 * Limitations:
 * ------------
 * This design does not currently contain an FCS
 * calculator, so instead it contains 2 fixed FCS values, which
 * correspond to a pkt_len of 16 words and 374 words respectively.
 * The FCS values are based on MAC dst and src addresses of
 * FF FF FF FF 1E 00 and FF FF A4 A5 27 37, so although the design
 * allows for configuration of MAC addresses and packet length, it
 * will only function using the values mentioned above. An FCS
 * calculator will be a future addition to this example design.
 */
void txd_handler(stream<axiWord>& txd,
		stream<ap_uint<1> >& txc_trig,
		stream<ap_uint<1> >& force_error_trig,
		stream<param_struct>& param_strm){
#pragma HLS pipeline II=1 enable_flush

	  static enum tState {TXD_INIT = 0, TXD_IDLE, TXD_MAC_0, TXD_MAC_1, TXD_MAC_2,
		  TXD_ETHERTYPE,TXD_PAYLOAD,TXD_FCS} txdState;
	  static ap_uint<32> lfsr = 0xFFFFFFFF;
	  static ap_uint<32> i = 0;
	  static ap_uint<1> force_err = 0;

	  static axiWord currWord = {0, 0xF, 0};
	  static param_struct params = {0,0,0,0,0,0};

	  switch(txdState) {
	  case TXD_INIT:
		  if(!param_strm.empty()){
			  // Read the parameters
			  param_strm.read(params);
			  // Trigger the TXC handler to start a frame
			  txc_trig.write(1);
			  txdState = TXD_IDLE;
		  }
		  break;

	  case TXD_IDLE:
		  // Reset the LFSR
		  lfsr = 0xFFFFFDA3;
		  // Reset the AXIS last signal
		  currWord.last = 0;
		  txdState = TXD_MAC_0;
		  break;

	  case TXD_MAC_0:
		  // Output the MAC address word 0
		  currWord.data = params.mac_addr_0;
		  txd.write(currWord);
		  txdState = TXD_MAC_1;
		  break;

	  case TXD_MAC_1:
		  // Output the MAC address word 1
		  currWord.data = params.mac_addr_1;
		  txd.write(currWord);
		  txdState = TXD_MAC_2;
		  break;

	  case TXD_MAC_2:
		  // Output the MAC address word 2
		  currWord.data = params.mac_addr_2;
		  txd.write(currWord);
		  txdState = TXD_ETHERTYPE;
		  break;

	  case TXD_ETHERTYPE:
		  // Output the EtherType word + padding
		  currWord.data = params.ethertype;
		  txd.write(currWord);
		  txdState = TXD_PAYLOAD;
		  i = 0;
		  break;

	  case TXD_PAYLOAD:
		  // Output the payload (random data)
		  // Calculate new LFSR value, replace old one
		  currWord.data = lfsr_next(&lfsr);
		  txd.write(currWord);
		  if(i == (params.pkt_len - 1))
			  txdState = TXD_FCS;
		  i++;
		  break;

	  case TXD_FCS:
		  // Output the FCS and generate error if requested
		  if(!force_error_trig.empty()){
			  force_error_trig.read(force_err);
			  currWord.data = params.fcs xor 0x10000000;
		  } else {
			  currWord.data = params.fcs;
		  }
		  currWord.last = 1;
		  txd.write(currWord);
		  // Trigger the TXC handler to start another frame
		  txc_trig.write(1);
		  txdState = TXD_IDLE;
		  break;

	  }
}


/* ----------------------------------------------
 * RXS Receive handler
 * ----------------------------------------------
 * Reads incoming frames on RXS and does nothing with the data.
 *
 */
void rxs_handler(stream<axiWord>& rxs){
#pragma HLS pipeline II=1 enable_flush
	  static enum rsState {R_INIT = 0, R_IDLE, R_FRAME} rxsState;

	  axiWord rxWord = {0, 0xF, 0};

	  switch(rxsState) {
	  case R_INIT:
		  rxsState = R_IDLE;
		  break;
	  case R_IDLE:
		  rxsState = R_FRAME;
		  break;
	    case R_FRAME:
			// Read the RXS frame
	    	if(!rxs.empty()){
	    		rxs.read(rxWord);
	    		if(rxWord.last == 1){
	    			rxsState = R_IDLE;
	    		}
	    	}
	    	break;
	  }
}


/* ----------------------------------------------
 * Error count function
 * ----------------------------------------------
 * Compares two words and returns the number of bit differences.
 *
 */
ap_uint<32> error_count(ap_uint<32> data, ap_uint<32> expected){
#pragma HLS pipeline II=1 enable_flush
	ap_uint<32> error_mask = 0;
	ap_uint<32> error_count = 0;
	ap_uint<32> i = 0;

	error_mask = data xor expected;

	for(i = 0; i<32; i++){
		error_count += error_mask[i];
	}

	return(error_count);
}


/* ----------------------------------------------
 * RXD Receive handler
 * ----------------------------------------------
 * Reads incoming frames on RXD and checks for bit errors.
 * We are able to check every word for errors because the TXD
 * handler always sends the same frame and we know what it is.
 * Most bit errors will get caught by the MAC FCS resulting in
 * dropped frames, but we check the received packets anyway
 * just to cover the possibility that they slip through.
 *
 */
void rxd_handler(stream<axiWord>& rxd,stream<ap_uint<32> >& err_strm,
		stream<param_struct>& param_strm){
#pragma HLS pipeline II=1 enable_flush
	  static enum rdState {R_INIT = 0, R_MAC_0, R_MAC_1, R_MAC_2,
		  R_ETHERTYPE, R_PAYLOAD, R_FCS, R_TRAILER} rxdState;

	  axiWord rxWord = {0, 0xF, 0};
	  static param_struct params = {0,0,0,0,0,0};
	  static ap_uint<32> lfsr = 0xFFFFFFFF;
	  static ap_uint<32> i = 0;

	  switch(rxdState) {
	  case R_INIT:
		  if(!param_strm.empty()){
			  // Read the parameters
			  param_strm.read(params);
			  rxdState = R_MAC_0;
		  }
		  break;
	  case R_MAC_0:
		  // Wait for MAC0 word
		  if(!rxd.empty()){
			  rxd.read(rxWord);
			  err_strm.write(error_count(rxWord.data,params.mac_addr_0));
			  if(rxWord.last == 1){
				  rxdState = R_MAC_0;
			  } else {
				  // Reset the LFSR
				  lfsr = 0xFFFFFDA3;
				  rxdState = R_MAC_1;
			  }
		  }
		  break;
	  case R_MAC_1:
		  // Wait for MAC1 word
		  if(!rxd.empty()){
			  rxd.read(rxWord);
			  err_strm.write(error_count(rxWord.data,params.mac_addr_1));
			  if(rxWord.last == 1)
				  rxdState = R_MAC_0;
			  else
				  rxdState = R_MAC_2;
		  }
		  break;
	  case R_MAC_2:
		  // Wait for MAC2 word
		  if(!rxd.empty()){
			  rxd.read(rxWord);
			  err_strm.write(error_count(rxWord.data,params.mac_addr_2));
			  if(rxWord.last == 1)
				  rxdState = R_MAC_0;
			  else
				  rxdState = R_ETHERTYPE;
		  }
		  break;
	  case R_ETHERTYPE:
		  // Wait for Ethertype word
		  if(!rxd.empty()){
			  rxd.read(rxWord);
			  err_strm.write(error_count(rxWord.data,params.ethertype));
			  if(rxWord.last == 1)
				  rxdState = R_MAC_0;
			  else {
				  // Initialize the packet length counter
				  i = 0;
				  rxdState = R_PAYLOAD;
			  }
		  }
		  break;
	  case R_PAYLOAD:
		  // Read the payload and compare with LFSR
			if(!rxd.empty()){
				rxd.read(rxWord);
				err_strm.write(error_count(rxWord.data,lfsr_next(&lfsr)));
				if(rxWord.last == 1)
					rxdState = R_MAC_0;
				else if(i == (params.pkt_len - 1))
					rxdState = R_FCS;
				i++;
			}
		  break;
	  case R_FCS:
		  // Wait for FCS (should be the last word in the frame)
		  if(!rxd.empty()){
			  rxd.read(rxWord);
			  err_strm.write(error_count(rxWord.data,params.fcs));
			  if(rxWord.last == 1)
				  rxdState = R_MAC_0;
			  else
				  rxdState = R_TRAILER;
		  }
		  break;
	  case R_TRAILER:
		  // Trailer state should never happen.
		  // Wait until the end of the frame.
		  // Probably should flag this occurrence to a software register.
		  if(!rxd.empty()){
			  rxd.read(rxWord);
			  if(rxWord.last == 1)
				  rxdState = R_MAC_0;
		  }
		  break;

	  }
}


/* ----------------------------------------------
 * Error counter
 * ----------------------------------------------
 * Receives error counts from the RXD handler, keeps the sum and writes
 * that value to the software register.
 *
 */
void error_counter(stream<ap_uint<32> >& err_strm,ap_uint<32> *err_count) {
#pragma HLS pipeline II=1 enable_flush
	static ap_uint<32> errors = 0;
	  ap_uint<32> count = 0;

	if(!err_strm.empty()){
		err_strm.read(count);
		errors = errors + count;
	}
	*err_count = errors;
}


/* ----------------------------------------------
 * Initialize parameters
 * ----------------------------------------------
 * Waits for valid values on the software registers and sends
 * them to the TXD and RXD handlers over a stream.
 *
 */
void init_params(ap_uint<32> *dst_mac_lo,
		ap_uint<32> *dst_mac_hi,
		ap_uint<32> *src_mac_lo,
		ap_uint<32> *src_mac_hi,
		ap_uint<32> *pkt_len,
		stream<param_struct>& param_strm_txd,
		stream<param_struct>& param_strm_rxd) {
#pragma HLS pipeline II=1 enable_flush
	static ap_uint<1> init_flag = 0;

	param_struct params = {0,0,0,0,0,0};

	// Initialize sub-blocks with software register values
	// Only gets executed once
	if(init_flag == 0){
		if((*pkt_len != 0)){
			// calculate the MAC address frame words
			combine_mac_addr(*dst_mac_lo,*dst_mac_hi,*src_mac_lo,*src_mac_hi,
					&params.mac_addr_0,&params.mac_addr_1,&params.mac_addr_2);
			// Calculate the Ethertype
			params.ethertype = calc_ethertype(*pkt_len);
			// Calculate FCS
			if(*pkt_len == 16){
				params.fcs = 0x58309809;
			}
			else if(*pkt_len == 374){
				params.fcs = 0x89C8FF96;
			}
			// Packet length
			params.pkt_len = *pkt_len;
			// Pass parameters to TXD handler
			param_strm_txd.write(params);
			// Pass parameters to RXD handler
			param_strm_rxd.write(params);
			init_flag = 1;
		}
	}
}


// Top level function
void eth_traffic_gen(stream<axiWord>& m_axis_txc,stream<axiWord>& m_axis_txd,
		stream<axiWord>& s_axis_rxs,stream<axiWord>& s_axis_rxd,
		ap_uint<1> *force_error,
		ap_uint<32> *dst_mac_lo,
		ap_uint<32> *dst_mac_hi,
		ap_uint<32> *src_mac_lo,
		ap_uint<32> *src_mac_hi,
		ap_uint<32> *pkt_len,
		ap_uint<32> *err_count) {
#pragma HLS INTERFACE axis port=m_axis_txc
#pragma HLS INTERFACE axis port=m_axis_txd
#pragma HLS INTERFACE axis port=s_axis_rxs
#pragma HLS INTERFACE axis port=s_axis_rxd
#pragma HLS INTERFACE ap_ctrl_none port=return
#pragma HLS INTERFACE s_axilite port=force_error bundle=p0
#pragma HLS INTERFACE s_axilite port=dst_mac_lo bundle=p0
#pragma HLS INTERFACE s_axilite port=dst_mac_hi bundle=p0
#pragma HLS INTERFACE s_axilite port=src_mac_lo bundle=p0
#pragma HLS INTERFACE s_axilite port=src_mac_hi bundle=p0
#pragma HLS INTERFACE s_axilite port=pkt_len bundle=p0
#pragma HLS INTERFACE s_axilite port=err_count bundle=p0
#pragma HLS dataflow

	// Force error trigger stream
	static stream<ap_uint<1> > force_error_trig;
#pragma HLS STREAM variable=force_error_trig depth=4 dim=1

	// Configuration parameter stream for TXD
	static stream<param_struct> param_strm_txd;
#pragma HLS STREAM variable=param_strm_txd depth=4 dim=1

	// Configuration parameter stream for RXD
	static stream<param_struct> param_strm_rxd;
#pragma HLS STREAM variable=param_strm_rxd depth=4 dim=1

	// Stream for synchronization of TXC and TXD handlers
	static stream<ap_uint<1> > txc_trig;
#pragma HLS STREAM variable=txc_trig depth=4 dim=1

	// Stream for error counting
	static stream<ap_uint<32> > err_strm;
#pragma HLS STREAM variable=err_strm depth=128 dim=1

	// Initialize parameters
	init_params(dst_mac_lo,dst_mac_hi,src_mac_lo,src_mac_hi,pkt_len,param_strm_txd,param_strm_rxd);

	// Waits for force error register toggle and triggers error
	force_error_handler(force_error,force_error_trig);

	// Error counter
	error_counter(err_strm,err_count);

	// Run the transmit and receive handlers
	txc_handler(m_axis_txc,txc_trig);
	txd_handler(m_axis_txd,txc_trig,force_error_trig,param_strm_txd);
	rxs_handler(s_axis_rxs);
	rxd_handler(s_axis_rxd,err_strm,param_strm_rxd);
}
