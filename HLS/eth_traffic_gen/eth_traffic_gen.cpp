/* ----------------------------------------------
 * Ethernet Traffic Generator
 * ----------------------------------------------
 * This IP generates Ethernet frames to be sent to the AXI Ethernet Subsystem block.
 * The frames contain random data generated by an LFSR for simple verification at the
 * receiver.
 *
 * The frame generator provides the FCS (checksum) to the MAC. Normally we wouldn't
 * provide the FCS to the MAC because it can calculate it automatically, but in our
 * case, we need to provide it so that we can generate forced errors in the frame
 * which will cause the FCS to be incorrect for the frame. Thus the receiver MAC will
 * reject it, and we can count a rejected frame.
 *
 */
#include <stdio.h>
#include <hls_stream.h>
#include <ap_int.h>

using namespace hls;

struct axiWord {
  ap_uint<32> data;
  ap_uint<4> keep;
  ap_uint<1> last;
};


/* ----------------------------------------------
 * Combine MAC addresses
 * ----------------------------------------------
 * Combines DST and SRC MAC addresses into the 3 words that
 * are used in the Ethernet frame.
 *
 */
void combine_mac_addr(ap_uint<32> dst_mac_lo,
		ap_uint<32> dst_mac_hi,
		ap_uint<32> src_mac_lo,
		ap_uint<32> src_mac_hi,
		ap_uint<32> *mac_addr) {
	ap_uint<16> uint16_hi;
	ap_uint<16> uint16_lo;
	// combine dest and src mac addresses into the 3 x 32 bit words
	uint16_hi = dst_mac_hi.range(15,0);
	uint16_lo = dst_mac_lo.range(31,16);
	mac_addr[0] = uint16_hi.concat(uint16_lo);

	uint16_hi = dst_mac_lo.range(15,0);
	uint16_lo = src_mac_hi.range(15,0);
	mac_addr[1] = uint16_hi.concat(uint16_lo);

	mac_addr[2] = src_mac_lo;
}

/* ----------------------------------------------
 * Ethertype calculator
 * ----------------------------------------------
 * Generates the Ethertype word based on the packet length.
 *
 */
ap_uint<32> calc_ethertype(unsigned int pkt_len) {
	ap_uint<8> uint8_hi;
	ap_uint<8> uint8_lo;
	ap_uint<16> pkt_len_bytes;

	// Convert the packet length in words, to packet length in bytes
	pkt_len_bytes = (pkt_len * 4) + 2;
	// Then switch byte order to form the Ethertype
	uint8_hi = pkt_len_bytes.range(7,0);
	uint8_lo = pkt_len_bytes.range(15,8);
	return(uint8_hi.concat(uint8_lo));
}

/* ----------------------------------------------
 * LFSR Random number generator
 * ----------------------------------------------
 * Generates random data for the transmitted Ethernet frames.
 *
 */
ap_uint<32> lfsr_next(ap_uint<32> *lfsr) {
	if((*lfsr)[31] == 1){
		*lfsr = (((*lfsr) ^ 0x00000062) << 1) | 1;
	}
	else{
		*lfsr = ((*lfsr) << 1);
	}

	return(*lfsr);
}

/* ----------------------------------------------
 * Force error handler
 * ----------------------------------------------
 * Monitors the force_error software register and triggers a bit error
 * when low-to-high transition is detected. Bit error is triggered by
 * writing to the force_error_trig stream.
 *
 */
void force_error_handler(ap_uint<1> *force_error,stream<ap_uint<1> >& force_error_trig) {
	static ap_uint<1> sig_r = 0;

	if(sig_r != *force_error){
		if((*force_error == 1) && (sig_r == 0)){
			force_error_trig.write(1);
		}
		sig_r = *force_error;
	}
}


/* ----------------------------------------------
 * TXC Transmit handler
 * ----------------------------------------------
 * Transmits control frames to the AXI Ethernet Subsystem.
 *
 */
void txc_handler(stream<axiWord>& txc,
				stream<ap_uint<1> >& txc_trig){
#pragma HLS pipeline II=1 enable_flush
	static enum txcState {TXC_IDLE = 0, TXC_CTRLFRAME} txcState;

	axiWord currWord = {0, 0xF, 0};

	switch(txcState) {
	case TXC_IDLE:
		// Wait for the TXD handler to trigger a frame
		if(!txc_trig.empty()){
			txc_trig.read();
			txcState = TXC_CTRLFRAME;
		}
		break;

	case TXC_CTRLFRAME:
		// Send the control frame
		currWord.last = 0;
		currWord.data = 0xA0000000;
		txc.write(currWord);
		for(ap_uint<16> i = 0; i < 4; i++){
			currWord.data = 0;
			txc.write(currWord);
		}
		// Output the last word
		currWord.data = 0;
		currWord.last = 1;
		txc.write(currWord);
		txcState = TXC_IDLE;
		break;
	  }
}


/* ----------------------------------------------
 * TXD Transmit handler
 * ----------------------------------------------
 * Transmits Ethernet frames to the AXI Ethernet Subsystem.
 * The frames are composed as follows:
 *  - 3 words for destination and source MAC addresses
 *  - 1 word for Ethertype and padding
 *  - n words for the payload where n=pkt_len_r
 *  - 1 word for FCS (checksum)
 *
 * The AXIS interface is 32 bits (one word).
 * The AXIS keep outputs are always 1, ie. all bytes are used.
 * The payload is filled with random data generated from an
 * LFSR.
 *
 * Limitations:
 * ------------
 * This design does not currently contain an FCS
 * calculator, so instead it contains 2 fixed FCS values, which
 * correspond to a pkt_len of 16 words and 374 words respectively.
 * The FCS values are based on MAC dst and src addresses of
 * FF FF FF FF 1E 00 and FF FF A4 A5 27 37, so although the design
 * allows for configuration of MAC addresses and packet length, it
 * will only function using the values mentioned above. An FCS
 * calculator will be a future addition to this example design.
 */
void txd_handler(stream<axiWord>& txd,
		stream<ap_uint<1> >& txc_trig,
		stream<ap_uint<1> >& force_error_trig,
		stream<ap_uint<32> >& param_strm){
#pragma HLS pipeline II=1 enable_flush

	  static enum tState {TXD_INIT = 0, TXD_IDLE, TXD_DATAFRAME} txdState;
	  static ap_uint<32> fcs = 0;
	  static ap_uint<32> mac_addr[3] = {0,0,0};
	  static ap_uint<32> ethertype = 0;
	  static ap_uint<32> lfsr = 0xFFFFFFFF;
	  static ap_uint<1> force_err = 0;
	  static ap_uint<32> pkt_len_r = 0;
	  static ap_uint<32> dst_mac_lo_r = 0;
	  static ap_uint<32> dst_mac_hi_r = 0;
	  static ap_uint<32> src_mac_lo_r = 0;
	  static ap_uint<32> src_mac_hi_r = 0;

	  axiWord currWord = {0, 0xF, 0};

	  switch(txdState) {
	  case TXD_INIT:
		  if(!param_strm.empty()){
			  // Read the software registers and register the values
			  dst_mac_lo_r = param_strm.read();
			  dst_mac_hi_r = param_strm.read();
			  src_mac_lo_r = param_strm.read();
			  src_mac_hi_r = param_strm.read();
			  pkt_len_r = param_strm.read();
			  // Form the mac address bytes from registers
			  combine_mac_addr(dst_mac_lo_r,dst_mac_hi_r,src_mac_lo_r,src_mac_hi_r,mac_addr);
			  // Calculate the Ethertype
			  ethertype = calc_ethertype(pkt_len_r);
			  // Calculate FCS
			  if(pkt_len_r == 16){
				  fcs = 0x58309809;
			  }
			  else if(pkt_len_r == 374){
				  fcs = 0x89C8FF96;
			  }
			  // Trigger the TXC handler to start a frame
			  txc_trig.write(1);
			  txdState = TXD_IDLE;
		  }
		  break;

	  case TXD_IDLE:
		  // Reset the LFSR
		  lfsr = 0xFFFFFDA3;
		  txdState = TXD_DATAFRAME;
		  break;

	  case TXD_DATAFRAME:
		  // Output the MAC address words
		  currWord.last = 0;
		  for(ap_uint<16> i = 0; i < 3; i++){
			currWord.data = mac_addr[i];
			txd.write(currWord);
		  }

		  // Output the EtherType word + padding
		  currWord.data = ethertype;
		  txd.write(currWord);

		  // Output the frame payload
		  for(ap_uint<32> i = 0; i < pkt_len_r; i++){
			  // Calculate new LFSR value, replace old one
			  currWord.data = lfsr_next(&lfsr);
			  txd.write(currWord);
		  }

		  // Output the FCS and generate error if requested
		  if(force_error_trig.read_nb(force_err)){
			  currWord.data = fcs xor 0x10000000;
		  } else {
			  currWord.data = fcs;
		  }
		  currWord.last = 1;
		  txd.write(currWord);

		  // Trigger the TXC handler to start another frame
		  txc_trig.write(1);
		  txdState = TXD_IDLE;
		  break;

	  }
}


/* ----------------------------------------------
 * RXS Receive handler
 * ----------------------------------------------
 * Reads incoming frames on RXS and does nothing with the data.
 *
 */
void rxs_handler(stream<axiWord>& rxs){
#pragma HLS pipeline II=1 enable_flush
	  static enum rsState {R_INIT = 0, R_IDLE, R_FRAME} rxsState;

	  axiWord rxWord = {0, 0xF, 0};

	  switch(rxsState) {
	  case R_INIT:
		  rxsState = R_IDLE;
		  break;
	  case R_IDLE:
		  rxsState = R_FRAME;
		  break;
	    case R_FRAME:
			// Read the RXS frame
	    	if(!rxs.empty()){
	    		rxs.read(rxWord);
	    		if(rxWord.last == 1){
	    			rxsState = R_IDLE;
	    		}
	    	}
	    	break;
	  }
}


/* ----------------------------------------------
 * RXD Receive handler
 * ----------------------------------------------
 * Reads incoming frames on RXD and does nothing with the data.
 *
 */
void rxd_handler(stream<axiWord>& rxd){
#pragma HLS pipeline II=1 enable_flush
	  static enum rdState {R_INIT = 0, R_IDLE, R_FRAME} rxdState;

	  axiWord rxWord = {0, 0xF, 0};

	  switch(rxdState) {
	  case R_INIT:
		  	rxdState = R_IDLE;
		  	break;
	  case R_IDLE:
		  	rxdState = R_FRAME;
		  	break;
	  case R_FRAME:
			// Read the RXD frame
	    	if(!rxd.empty()){
	    		rxd.read(rxWord);
	    		if(rxWord.last == 1){
	    			rxdState = R_IDLE;
	    		}
	    	}
	    	break;
	  }
}


// Top level function
void eth_traffic_gen(stream<axiWord>& m_axis_txc,stream<axiWord>& m_axis_txd,
		stream<axiWord>& s_axis_rxs,stream<axiWord>& s_axis_rxd,
		ap_uint<1> *force_error,
		ap_uint<32> *dst_mac_lo,
		ap_uint<32> *dst_mac_hi,
		ap_uint<32> *src_mac_lo,
		ap_uint<32> *src_mac_hi,
		ap_uint<32> *pkt_len) {
#pragma HLS INTERFACE axis depth=128 port=m_axis_txc
#pragma HLS INTERFACE axis depth=128 port=m_axis_txd
#pragma HLS INTERFACE axis depth=128 port=s_axis_rxs
#pragma HLS INTERFACE axis depth=128 port=s_axis_rxd
#pragma HLS INTERFACE s_axilite port=return bundle=0
#pragma HLS INTERFACE s_axilite port=force_error bundle=0
#pragma HLS INTERFACE s_axilite port=dst_mac_lo bundle=0
#pragma HLS INTERFACE s_axilite port=dst_mac_hi bundle=0
#pragma HLS INTERFACE s_axilite port=src_mac_lo bundle=0
#pragma HLS INTERFACE s_axilite port=src_mac_hi bundle=0
#pragma HLS INTERFACE s_axilite port=pkt_len bundle=0
#pragma HLS dataflow

	static ap_uint<1> init_flag = 0;

	// Force error trigger stream
	static stream<ap_uint<1> > force_error_trig;
#pragma HLS STREAM variable=force_error_trig depth=4 dim=1

	// Configuration parameter stream for TXD
	static stream<ap_uint<32> > param_strm_txd;
#pragma HLS STREAM variable=param_strm_txd depth=4 dim=1

	// Stream for synchronization of TXC and TXD handlers
	static stream<ap_uint<1> > txc_trig;
#pragma HLS STREAM variable=txc_trig depth=4 dim=1

	// Initialize sub-blocks with software register values
	// Only gets executed once
	if(init_flag == 0){
		if(*pkt_len > 0){
			param_strm_txd.write(*dst_mac_lo);
			param_strm_txd.write(*dst_mac_hi);
			param_strm_txd.write(*src_mac_lo);
			param_strm_txd.write(*src_mac_hi);
			param_strm_txd.write(*pkt_len);
			init_flag = 1;
		}
	}

	// Waits for force error register toggle and triggers error
	force_error_handler(force_error,force_error_trig);

	// Run the transmit and receive handlers
	txc_handler(m_axis_txc,txc_trig);
	txd_handler(m_axis_txd,txc_trig,force_error_trig,param_strm_txd);
	rxs_handler(s_axis_rxs);
	rxd_handler(s_axis_rxd);
}
